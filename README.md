## part13 
https://fullstackopen.com/en/part13

### Relational databases

Throughout the course we used MongoDB for storing data, a schemaless document database. Among [other comparisons](https://www.mongodb.com/compare/relational-vs-non-relational-databases), some advantages of a non-relational database are flexibility and speed/scale at the cost of structure and reliability ([ACID Transactions](https://www.mongodb.com/basics/acid-transactions)). The end product of this part, found here, is a backend for the bloglist app built in part [4](https://github.com/jamessl154/fullstackopen/tree/main/part4) but replacing MongoDB and Mongoose with the relational database [PostgreSQL](https://www.postgresql.org/) and the ORM [Sequelize](https://sequelize.org/v6/) for the process of storing data.

To simplify development we used [Heroku Postgres](https://devcenter.heroku.com/articles/heroku-postgresql) to host the database. We started very simply using the command line to create a table, in ```commands.sql```, and a CLI program to print the data, ```cli.js```. We then moved on to using [models](https://sequelize.org/master/manual/model-basics.html) to represent the tables, in ```models/```, and their [relationships](https://sequelize.org/master/manual/assocs.html) in ```models/index.js```. Implemented a [many-to-many](https://sequelize.org/v7/manual/advanced-many-to-many.html) relationship using a connection table that represented a reading list feature, all users have access to all blogs when adding to their reading list.

The full database configuration can be found in ```util/db.js```. Rather than relying on the [Model.sync()](https://sequelize.org/master/manual/model-basics.html#model-synchronization) method to update the database, we used [migrations](https://sequelize.org/master/manual/migrations.html) to keep a record of changes to the database which also allowed us to roll back single changes that I made possible using the command ```npm run migration:down```. Used [express-async-errors](https://github.com/davidbanham/express-async-errors), allowing us to remove try catch boilerplate, because asynchronous errors are not caught in express by default. Centralized error handling into an error handling middleware found in ```controllers/errorHandler.js```.

I implemented all the functionality, validation and error handling for the route handlers in ```controllers/``` and middleware they rely on in ```util/middleware.js```. This included a reading list, hashing passwords, token authorization, disabling users, admin privileges and server-side sessions. The final task was to implement server-side sessions as a solution to the problem in our application of infinitely valid tokens which is abusable e.g. user logs into client, the account gets disabled but they still have access or the token is intercepted/tokens are breached. I implemented this by storing the token strings in a sessions table. Always first removing a user's existing sessions on login, then creating a session. When the user trys to access token-authorized routes, the middleware ```tokenExtractor.js``` looks up the token in the sessions table to verify the token has valid access. Logging out or a user being disabled by an admin deletes a user's sessions.